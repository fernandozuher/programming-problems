// Source: https://www.hackerrank.com/challenges/jumping-on-the-clouds-revisited/problem?isFullScreen=true

'use strict';

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString: string = '';
let inputLines: string[] = [];
let currentLine: number = 0;

process.stdin.on('data', function(inputStdin: string): void {
    inputString += inputStdin;
});

process.stdin.on('end', function(): void {
    inputLines = inputString.split('\n');
    inputString = '';

    main();
});

function readLine(): string {
    return inputLines[currentLine++];
}

function main() {
    let array: Array<number> = readAnArray();
    const _SIZE_ARRAY: number = array[0];
    const JUMP_LENGTH: number = array[1];
    array = readAnArray();

    const ENERGY: number = jumpingOnClouds(array, JUMP_LENGTH);
    console.log(ENERGY);
}

    function readAnArray(): Array<number> {
        const ARRAY: Array<number> = readLine().split(" ").map(Number);
        return ARRAY;
    }

    function jumpingOnClouds(array: Array<number>, jumpLength: number): number {
        let energy: number = 100;

        for (let cloudIndex: number = 0; true; ) {
            energy -= spentEnergyAccordingToTypeOfCloud(array[cloudIndex]);
            cloudIndex = generateNewCloudIndex(cloudIndex, array.length, jumpLength);
            if (isCloudIndexBackToFirstCloud(cloudIndex)) {
                break;
            }
        }

        return energy;
    }

        function spentEnergyAccordingToTypeOfCloud(cloudType: number): number {
            return cloudType == 0 ? 1 : 3;
        }

        function generateNewCloudIndex(cloudIndex: number, sizeArray: number, jumpLength: number): number {
            return (cloudIndex + jumpLength) % sizeArray;
        }

        function isCloudIndexBackToFirstCloud(cloudIndex: number): bool {
            return cloudIndex == 0;
        }
